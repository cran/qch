#' @import utils
## quiets concerns of R CMD check re: the .'s that appear in pipelines
#if(getRversion() >= "2.15.1")  utils::globalVariables(c(".",">"))
if(getRversion() >= "2.15.1")  utils::globalVariables(c(".",":=",".x",">"))

###################################################################
#' Infer posterior probabilities of \eqn{H_0}/\eqn{H_1} configurations.
#'
#' For each item, estimate the posterior probability for each configuration.
#' This function use either the model accounting for the dependence structure
#'  through a Gaussian copula function (\code{copula=="gaussian"}) or
#' assuming the conditional independence (\code{copula=="indep"}).
#' Utilizes parallel computing, when available. For package documentation, see \code{\link{qch-package}}.
#'
#' @param pValMat A matrix of p-values, each column corresponding to a p-value serie.
#' @param EffectMat A matrix of estimated effects corresponding to the p-values contained in pValMat. If specified, the procedure will account for the direction of the effect. (optional, default is \code{NULL})
#' @param Hconfig A list of all possible combination of \eqn{H_0} and \eqn{H_1} hypotheses generated by the [GetHconfig()] function.
#' @param copula A string specifying the form of copula to use. Possible values are "\code{indep}"and "\code{gaussian}". Default is "\code{indep}" corresponding to the independent case. 
#' @param threads_nb The number of threads to use. The number of thread will set to the number of core available by default.
#' @param plotting A boolean. Should some diagnostic graphs be plotted ? Default is \code{FALSE}.
#' @param Precision The precision for EM algorithm to infer the parameters. Default is \code{1e-6}. 
#' @import stats
#' @importFrom qvalue pi0est
#' 
#' @return A list with the following elements:
#' \tabular{ll}{
#' \code{prior} \tab vector of estimated prior probabilities 
#' for each of the H-configurations.\cr
#' \code{Rcopula} \tab the estimated correlation matrix of the Gaussian copula.
#' (if applicable)\cr
#' \code{Hconfig} \tab the list of all configurations.
#' }
#'
#' \itemize{
#' \item If the storage permits, the list will additionally contain:
#' \tabular{ll}{
#' \code{posterior} \tab matrix providing for each item (in row) its posterior probability to
#'  belong to each of the H-configurations (in columns).\cr
#' \code{fHconfig} \tab matrix containing \eqn{\psi_c} densities evaluated at each items,
#'  each column corresponding to a configuration.
#' }
#'
#' \item Else, the list will additionally contain:
#' \tabular{ll}{
#' \code{f0Mat} \tab matrix containing the evaluation of the marginal densities under \eqn{H_0} at each items,
#'  each column corresponding to a p-value serie.\cr
#' \code{f1Mat} \tab matrix containing the evaluation of the marginal densities under \eqn{H_1} at each items,
#'  each column corresponding to a p-value serie.\cr
#' \code{F0Mat} \tab matrix containing the evaluation of the marginal cdf under \eqn{H_0} at each items,
#'  each column corresponding to a p-value serie.\cr
#' \code{F1Mat} \tab matrix containing the evaluation of the marginal cdf under \eqn{H_1} at each items,
#'  each column corresponding to a p-value serie.\cr
#' \code{fHconfig_sum} \tab vector containing \eqn{(\sum_cw_c\psi_c(Z_i))} for each items \eqn{i}.\cr
#'  }
#'  }
#'
#' The elements of interest are the posterior probabilities matrix, \code{posterior},
#'  the estimated proportion of observations belonging to each configuration, \code{prior}, and
#'  the estimated correlation matrix of the Gaussian copula, \code{Rcopula}.
#' The remaining elements are returned primarily for use by other functions.
#'
#'
#' @export
#' 
#' @examples
#' data(PvalSets_cor)
#' PvalMat <- as.matrix(PvalSets_cor[,-3])
#' ## Build the Hconfig objects
#' Q <- 2
#' Hconfig <- GetHconfig(Q)
#'
#' ## Run the function
#' res.fit <- qch.fit(pValMat = PvalMat,Hconfig = Hconfig,copula="gaussian")
#'
#' ## Display the prior of each class of items
#' res.fit$prior
#' 
#' ## Display the correlation estimate of the gaussian copula
#' res.fit$Rcopula
#'
#' ## Display the first posteriors
#' head(res.fit$posterior)

qch.fit <- function(pValMat,EffectMat=NULL,Hconfig,copula="indep",threads_nb=0, plotting=FALSE,Precision=1e-6){
  
  n <- nrow(pValMat)
  Q <- ncol(pValMat)
  
  #for numerical precision problems
  pValMat <- pValMat %>% as.matrix()
  
  pValMat[which(pValMat==0)] <- min(pValMat[which(pValMat!=0)])
  pValMat[which(pValMat==1)] <- max(pValMat[which(pValMat!=1)])
  
  ### Check the dimension
  
  
  ### Check parameters
  if(copula!="indep" & copula!="gaussian"){
    stop("Error. Copula must be 'indep' or 'gaussian'.")
  }
  if(copula=="gaussian" & !is.null(EffectMat)){
    stop("Error. The procedure cannot take account of the direction of effects with a copula other than indep.")
  }

  ## Memory management 
  if(n*(2**Q)*8 > 2e9){#if the storage requirement exceeds 2Go
    memory_management <- TRUE
  }else{memory_management <- FALSE}

  
  #### Zscores computation
  if(is.null(EffectMat)){
    XMat <- -qnorm(pValMat)
  }else{
    XMat <- -qnorm(pValMat/2)* sign(EffectMat)
  }
  
  #### Step 1: Marginal density estimation
  
  ## Get p0 estimates
  p0 <- rep(0, Q)
  for (q in 1:Q){
    p0[q] <- min(qvalue::pi0est(p=pValMat[,q],pi0.method = "bootstrap")$pi0,1-1/n)
  }
  SomeH1 <-  which(p0<1)
  NoH1 <- which(p0==1-1/n);
  if(length(NoH1)==1){
    message(paste("Pvalue serie",NoH1, "may have very few H1 (or a weird distribution)"))
  }
  if(length(NoH1)>1){
    message(paste("Pvalue series",paste(NoH1,collapse=' '), "may have very few H1 (or a weird distribution)"))
  }
  
  ## Fit a 2-component mixture to each test serie using kerFdr
  f1Mat <- matrix(1, n, Q)
  F1Mat <- matrix(1, n, Q)
  if(is.null(EffectMat)){
    for(q in SomeH1){
      ker <- FastKerFdr_unsigned(XMat[, q], p0=p0[q], plotting)
      f1Mat[,q] <- ker$f1
      F1Mat[,q] <- ker$F1
      p0[q] <- ker$p0
    }
  }else{
    for(q in SomeH1){
      ker <- FastKerFdr_signed(XMat[, q], p0=p0[q], plotting=FALSE)
      f1Mat[,q] <- ker$f1
      F1Mat[,q] <- ker$F1
      p0[q] <- ker$p0
    }
    f1_signed <- f1_separation_signed(XMat,f0Mat,f1Mat,p0,plotting)
  }
  
  f0Mat <- matrix(dnorm(XMat),ncol=Q)
  F0Mat <- pnorm(XMat,mean = 0,sd = 1)
  
  #for numerical precision problems
  F0Mat[which(F0Mat>1-1e-12)] <- 1-1e-12
  F0Mat[which(F0Mat<1e-12)] <- 1e-12
  F1Mat[which(F1Mat>1-1e-12)] <- 1-1e-12
  F1Mat[which(F1Mat<1e-12)] <- 1e-12
  
  
  #### Step 1bis: transform marginal densities into config densities
  
  Logf0Mat <- log(f0Mat)
  if(is.null(EffectMat)){
    Logf1Mat <- log(f1Mat)
    if(!memory_management){
      fHconfig <- sapply(Hconfig, function(h){
        f <- rep(0,nrow(Logf0Mat))
        if (length(which(h==1)) > 0){f <- f + rowSums(Logf1Mat[, which(h==1), drop=FALSE])}
        if (length(which(h==0)) > 0){f <- f + rowSums(Logf0Mat[, which(h==0), drop=FALSE])}
        return(exp(f))
      })
    }
  }else{
    Logf1plusMat <- log(f1_signed$f1plusMat)
    Logf1minusMat <- log(f1_signed$f1minusMat)
    if(!memory_management){
      fHconfig <- sapply(Hconfig, function(h){
        f <- rep(0,nrow(f0Mat))
        if(length(which(h=="+")) > 0){f <- f + rowSums(Logf1plusMat[, which(h=="+"), drop=FALSE])}
        if(length(which(h=="-")) > 0){f <- f + rowSums(Logf1minusMat[, which(h=="-"), drop=FALSE])}
        if(length(which(h==0)) > 0){f <- f + rowSums(Logf0Mat[, which(h==0), drop=FALSE])}
        return(exp(f))
      })
    }
  }
  
  #### Step 2: Infer parameters using an EM procedure
  
  ## Initialization: 
  # Weights: Simple product of marginal priors estimator
  if(is.null(EffectMat)){
    NewPrior <- sapply(1:length(Hconfig), function(c){
      prod(p0[which(Hconfig[[c]]==0)]) * prod(1-p0[which(Hconfig[[c]]==1)])
    })
  }else{
    NewPrior <- sapply(1:length(Hconfig), function(c){
      prod(p0[which(Hconfig[[c]]==0)]) * prod(f1_signed$p1plus[which(Hconfig[[c]]=='+')]) * prod(f1_signed$p1minus[which(Hconfig[[c]]=='-')])
    })
  }
  
  
  # Copula parameters: Kendall's tau estimator
  if(copula=="gaussian"){
    NewRho <- copula::fitCopula(copula = copula::normalCopula(dim = Q,dispstr="un"),data = pValMat[sample(1:n,size=min(1e4,n)),],method="itau") %>% coef()
    NewR <- copula::p2P(param = NewRho,d = Q)
  }
  
  ## EM calibration
  if(copula=="indep"){
    if(!memory_management){
      EM.res <- EM_calibration_indep(fHconfig = fHconfig,
                                     Prior.init = NewPrior,
                                     Precision = Precision)
    }else{
      EM.res <- EM_calibration_indep_memory(Logf0Mat = Logf0Mat,
                                            Logf1Mat = Logf1Mat,
                                            Prior.init = NewPrior,
                                            Hconfig = Hconfig,
                                            threads_nb = threads_nb,
                                            Precision = Precision )
    }
    
  }else if(copula=="gaussian"){
    if(!memory_management){
      EM.res<- EM_calibration_gaussian(Hconfig = Hconfig,
                                       F0Mat = F0Mat,
                                       F1Mat = F1Mat,
                                       fHconfig = fHconfig,
                                       R.init = NewR,
                                       Prior.init = NewPrior,
                                       Precision = Precision)
    }else{
      EM.res <- EM_calibration_gaussian_memory(Logf0Mat = Logf0Mat,
                                               Logf1Mat = Logf1Mat,
                                               F0Mat = F0Mat,
                                               F1Mat = F1Mat,
                                               Prior.init = NewPrior,
                                               R.init = NewR,
                                               Hconfig = Hconfig,
                                               threads_nb = threads_nb,
                                               Precision = Precision)
    }
    
  }
  
  #### Step 2bis: Posterior computation
  if(!memory_management){
    if(copula=="gaussian"){
      fcopula.Hconfig <- Copula.Hconfig_gaussian_density(Hconfig, F0Mat, F1Mat, EM.res$Rcopula) * fHconfig
      posterior <- fcopula.Hconfig*(tcrossprod(rep(1:n),EM.res$priorHconfig))
      posterior <- posterior/rowSums(posterior)
    }else if(copula=="indep"){
      posterior <- fHconfig*(tcrossprod(rep(1:n),EM.res$priorHconfig))
      posterior <- posterior/rowSums(posterior)
    }
  }else{
    if(copula=="gaussian"){
      RcopulaInv <- solve(EM.res$Rcopula)
      zeta0 <- qnorm(p = F0Mat,mean = 0,sd = 1)
      zeta1 <- qnorm(p = F1Mat,mean = 0,sd = 1)
      fHconfig_sum <- fHconfig_sum_update_gaussian_copula_ptr_parallel(Hconfig,
                                                                       EM.res$priorHconfig,
                                                                       Logf0Mat,Logf1Mat,
                                                                       zeta0,zeta1,
                                                                       EM.res$Rcopula,RcopulaInv,
                                                                       threads_nb = threads_nb) 
    }else if(copula=="indep"){
      fHconfig_sum <- fHconfig_sum_update_ptr_parallel(Hconfig,
                                                       EM.res$priorHconfig,
                                                       Logf0Mat,Logf1Mat,
                                                       threads_nb = threads_nb)
    }
  }
  
  
  #### Last but not least: output results
  if(!memory_management){
    Res <- list(prior=EM.res$priorHconfig,
                posterior=posterior,
                fHconfig=fHconfig,
                Rcopula = EM.res$Rcopula,
                Hconfig = names(Hconfig))
  }else{
    Res <- list(prior=EM.res$priorHconfig,
                f0Mat=f0Mat,f1Mat=f1Mat,
                F0Mat=F0Mat, F1Mat=F1Mat,
                fHconfig_sum=fHconfig_sum,
                Rcopula=EM.res$Rcopula,
                Hconfig = names(Hconfig))
  }
  
  return(Res)
  
}
